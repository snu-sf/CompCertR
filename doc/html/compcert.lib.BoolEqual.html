
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module BoolEqual</title>
<meta name="description" content="Documentation of Coq module BoolEqual" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module BoolEqual</h1>
<div class="coq">
<br/>
<div class="doc">Tactics to generate Boolean-valued equalities </div>
<br/>
<div class="doc">The <span class="bracket"><span class="id">decide</span> <span class="id">equality</span></span> tactic can generate a term of type
<span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">A</span>), {<span class="id">x</span>=<span class="id">y</span>} + {<span class="id">x</span>&lt;&gt;<span class="id">y</span>}</span> if <span class="bracket"><span class="id">A</span></span> is an inductive type.
This term is a decidable equality function.
Similarly, this module defines a <span class="bracket"><span class="id">boolean_equality</span></span> tactic that generates
a term of type <span class="bracket"><span class="id">A</span> -&gt; <span class="id">A</span> -&gt; <span class="id">bool</span></span>.  This term is a Boolean-valued equality
function over the inductive type <span class="bracket"><span class="id">A</span></span>.  Two internal tactics generate
proofs that show the correctness of this equality function <span class="bracket"><span class="id">f</span></span>, namely
proofs of the following two properties:
<ul>
<li>
 <span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span>: <span class="id">A</span>), <span class="id">f</span> <span class="id">x</span> <span class="id">x</span> = <span class="id">true</span></span>
</li>
<li>
 <span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">A</span>), <span class="id">f</span> <span class="id">x</span> <span class="id">y</span> = <span class="id">true</span> -&gt; <span class="id">x</span> = <span class="id">y</span></span>
</li>
</ul>
Finally, the <span class="bracket"><span class="id">decide_equality_from</span> <span class="id">f</span></span> tactic wraps <span class="bracket"><span class="id">f</span></span> (the Boolean equality
generated by <span class="bracket"><span class="id">boolean_equality</span></span>) and those proofs together, producing
a decidable equality of type <span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">A</span>), {<span class="id">x</span>=<span class="id">y</span>} + {<span class="id">x</span>&lt;&gt;<span class="id">y</span>}</span>.
The advantage of the present tactics over the standard <span class="bracket"><span class="id">decide</span> <span class="id">equality</span></span>
tactic is that the former produce smaller transparent definitions than
the latter.
For a type <span class="bracket"><span class="id">A</span></span> that has N constructors, <span class="bracket"><span class="id">decide</span> <span class="id">equality</span></span> produces a
single term of size O(N^3), which must be kept transparent so that
it computes and extracts as expected.  Given such a big transparent
definition, the virtual machine compiler of Coq produces very big
chunks of VM code, causing memory overflows on 32-bit platforms.
In contrast, the term produced by <span class="bracket"><span class="id">boolean_equality</span></span> has size O(N^2)
only (so to speak).  The proofs that this term is a correct boolean
equality are still O(N^3), but those proofs are opaque and do not need
to be compiled to VM code.  Only the boolean equality itself is defined
transparently and compiled.
The present tactics also have some restrictions:
<ul>
<li>
 Constructors must have at most 4 arguments.
</li>
<li>
 Decidable equalities must be provided (as hypotheses in the context)
  for all the types <span class="bracket"><span class="id">T</span></span> of constructor arguments other than type <span class="bracket"><span class="id">A</span></span>.
</li>
<li>
 They probably do not work for mutually-defined inductive types.
</li>
</ul>
</div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id"><a href="compcert.lib.Coqlib.html">Coqlib</a></span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id"><a name="BE">BE</a></span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id"><a name="BE.bool_eq">bool_eq</a></span> {<span class="id">A</span>: <span class="kwd">Type</span>} (<span class="id">x</span> <span class="id">y</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span>) : <span class="kwd">Type</span> := <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#bool">bool</a></span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_base</span> <span class="id">x</span> <span class="id">y</span> :=<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> <span class="id">x</span> <span class="id">y</span>);<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: ?<span class="id">A</span>), <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#bool">bool</a></span> |- @<span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> ?<span class="id">A</span> <span class="id">x</span> <span class="id">y</span> ] =&gt; <span class="tactic">exact</span> (<span class="id">H</span> <span class="id">x</span> <span class="id">y</span>)<br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: ?<span class="id">A</span>), {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>=<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>} + {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>&lt;&gt;<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>}  |- @<span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> ?<span class="id">A</span> <span class="id">x</span> <span class="id">y</span> ] =&gt; <span class="tactic">exact</span> (<span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span> (<span class="id">H</span> <span class="id">x</span> <span class="id">y</span>))<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_case</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> (?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span> ?<span class="id">x3</span> ?<span class="id">x4</span>) (?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span> ?<span class="id">y3</span> ?<span class="id">y4</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">refine</span> (<span class="id">_</span> &amp;&amp; <span class="id">_</span> &amp;&amp; <span class="id">_</span> &amp;&amp; <span class="id">_</span>); [<span class="id">bool_eq_base</span> <span class="id">x1</span> <span class="id">y1</span>|<span class="id">bool_eq_base</span> <span class="id">x2</span> <span class="id">y2</span>|<span class="id">bool_eq_base</span> <span class="id">x3</span> <span class="id">y3</span>|<span class="id">bool_eq_base</span> <span class="id">x4</span> <span class="id">y4</span>]<br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> (?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span> ?<span class="id">x3</span>) (?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span> ?<span class="id">y3</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">refine</span> (<span class="id">_</span> &amp;&amp; <span class="id">_</span> &amp;&amp; <span class="id">_</span>); [<span class="id">bool_eq_base</span> <span class="id">x1</span> <span class="id">y1</span>|<span class="id">bool_eq_base</span> <span class="id">x2</span> <span class="id">y2</span>|<span class="id">bool_eq_base</span> <span class="id">x3</span> <span class="id">y3</span>]<br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> (?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span>) (?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">refine</span> (<span class="id">_</span> &amp;&amp; <span class="id">_</span>); [<span class="id">bool_eq_base</span> <span class="id">x1</span> <span class="id">y1</span>|<span class="id">bool_eq_base</span> <span class="id">x2</span> <span class="id">y2</span>]<br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> (?<span class="id">C</span> ?<span class="id">x1</span>) (?<span class="id">C</span> ?<span class="id">y1</span>) =&gt; <span class="id">bool_eq_base</span> <span class="id">x1</span> <span class="id">y1</span><br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> ?<span class="id">C</span> ?<span class="id">C</span> =&gt; <span class="tactic">exact</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span><br/>
&nbsp;&nbsp;| |- <span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="tactic">exact</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#false">false</a></span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">A</span> -&gt; ?<span class="id">A</span> -&gt; <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#bool">bool</a></span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">f</span> := <span class="tactic">fresh</span> "<span class="id">rec</span>" <span class="kwd">in</span> <span class="kwd">let</span> <span class="id">x</span> := <span class="tactic">fresh</span> "<span class="id">x</span>" <span class="kwd">in</span> <span class="kwd">let</span> <span class="id">y</span> := <span class="tactic">fresh</span> "<span class="id">y</span>" <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fix</span> <span class="id">f</span> 1; <span class="tactic">intros</span> <span class="id">x</span> <span class="id">y</span>; <span class="id">change</span> (<span class="id"><a href="compcert.lib.BoolEqual.html#BE.bool_eq">bool_eq</a></span> <span class="id">x</span> <span class="id">y</span>); <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="id">bool_eq_case</span><br/>
&nbsp;&nbsp;| [ |- <span class="id">_</span> -&gt; <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">eq</span> := <span class="tactic">fresh</span> "<span class="id">eq</span>" <span class="kwd">in</span> <span class="tactic">intro</span> <span class="id">eq</span>; <span class="id">bool_eq</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="BE.proj_sumbool_is_true">proj_sumbool_is_true</a></span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span>), {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>=<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>} + {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>&lt;&gt;<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>}) (<span class="id">x</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span>),<br/>
&nbsp;&nbsp;<span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span> (<span class="id"><a href="compcert.lib.BoolEqual.html#f">f</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>) = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1186')">Proof.</div>
<div class="proofscript" id="proof1186">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">x</span> <span class="id">x</span>). <span class="tactic">auto</span>. <span class="tactic">elim</span> <span class="id">n</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_refl_case</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ |- <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> ] =&gt; <span class="tactic">reflexivity</span><br/>
&nbsp;&nbsp;| [ |- <span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span> <span class="id">_</span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="compcert.lib.BoolEqual.html#BE.proj_sumbool_is_true">proj_sumbool_is_true</a></span><br/>
&nbsp;&nbsp;| [ |- <span class="id">_</span> &amp;&amp; <span class="id">_</span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Bool.Bool.html#andb_true_iff">andb_true_iff</a></span>; <span class="tactic">split</span>; <span class="id">bool_eq_refl_case</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="tactic">auto</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_refl</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">H</span> := <span class="tactic">fresh</span> "<span class="id">Hrec</span>" <span class="kwd">in</span> <span class="kwd">let</span> <span class="id">x</span> := <span class="tactic">fresh</span> "<span class="id">x</span>" <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">fix</span> <span class="id">H</span> 1; <span class="tactic">intros</span> <span class="id">x</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span>; <span class="id">bool_eq_refl_case</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="BE.false_not_true">false_not_true</a></span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">P</span>: <span class="kwd">Prop</span>), <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#false">false</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> -&gt; <span class="id"><a href="compcert.lib.BoolEqual.html#P">P</a></span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1187')">Proof.</div>
<div class="proofscript" id="proof1187">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="BE.proj_sumbool_true">proj_sumbool_true</a></span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">x</span> <span class="id">y</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span>) (<span class="id">a</span>: {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>=<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>} + {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>&lt;&gt;<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>}),<br/>
&nbsp;&nbsp;<span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#a">a</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> -&gt; <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> = <span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1188')">Proof.</div>
<div class="proofscript" id="proof1188">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">auto</span>. <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_sound_case</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#false">false</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> |- <span class="id">_</span> ] =&gt; <span class="tactic">exact</span> (<span class="id"><a href="compcert.lib.BoolEqual.html#BE.false_not_true">false_not_true</a></span> <span class="id">_</span> <span class="id">H</span>)<br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id">_</span> &amp;&amp; <span class="id">_</span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> |- <span class="id">_</span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#andb_prop">andb_prop</a></span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">H</span>; <span class="id">bool_eq_sound_case</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id"><a href="compcert.lib.Coqlib.html#proj_sumbool">proj_sumbool</a></span> ?<span class="id">a</span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> |- <span class="id">_</span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="compcert.lib.BoolEqual.html#BE.proj_sumbool_true">proj_sumbool_true</a></span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">bool_eq_sound_case</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span> ?<span class="id">x3</span> ?<span class="id">x4</span> = ?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span> ?<span class="id">y3</span> ?<span class="id">y4</span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Logic.html#f_equal4">f_equal4</a></span>; <span class="tactic">auto</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span> ?<span class="id">x3</span> = ?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span> ?<span class="id">y3</span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Logic.html#f_equal3">f_equal3</a></span>; <span class="tactic">auto</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">C</span> ?<span class="id">x1</span> ?<span class="id">x2</span> = ?<span class="id">C</span> ?<span class="id">y1</span> ?<span class="id">y2</span> ] =&gt; <span class="tactic">apply</span> <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Logic.html#f_equal2">f_equal2</a></span>; <span class="tactic">auto</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">C</span> ?<span class="id">x1</span> = ?<span class="id">C</span> ?<span class="id">y1</span> ] =&gt; <span class="tactic">apply</span> <span class="tactic">f_equal</span>; <span class="tactic">auto</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id">x</span> = ?<span class="id">x</span> ] =&gt; <span class="tactic">reflexivity</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">bool_eq_sound</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">Hrec</span> := <span class="tactic">fresh</span> "<span class="id">Hrec</span>" <span class="kwd">in</span> <span class="kwd">let</span> <span class="id">x</span> := <span class="tactic">fresh</span> "<span class="id">x</span>" <span class="kwd">in</span> <span class="kwd">let</span> <span class="id">y</span> := <span class="tactic">fresh</span> "<span class="id">y</span>" <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">fix</span> <span class="id">Hrec</span> 1; <span class="tactic">intros</span> <span class="id">x</span> <span class="id">y</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>; <span class="tactic">intro</span>; <span class="id">bool_eq_sound_case</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id"><a name="BE.dec_eq_from_bool_eq">dec_eq_from_bool_eq</a></span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span> -&gt; <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span> -&gt; <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#bool">bool</a></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">f_refl</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id"><a href="compcert.lib.BoolEqual.html#f">f</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span>) (<span class="id">f_sound</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id"><a href="compcert.lib.BoolEqual.html#f">f</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> <span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span> = <span class="id"><a href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#true">true</a></span> -&gt; <span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span> = <span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>),<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id"><a href="compcert.lib.BoolEqual.html#A">A</a></span>), {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>=<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>} + {<span class="id"><a href="compcert.lib.BoolEqual.html#x">x</a></span>&lt;&gt;<span class="id"><a href="compcert.lib.BoolEqual.html#y">y</a></span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1189')">Proof.</div>
<div class="proofscript" id="proof1189">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">eqn</span>:<span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">apply</span> <span class="id">f_sound</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">y</span>. <span class="tactic">rewrite</span> <span class="id">f_refl</span> <span class="kwd">in</span> <span class="id">E</span>. <span class="tactic">discriminate</span>.<br/>
Defined.</div>
<br/>
<span class="kwd">End</span> <span class="id"><a href="compcert.lib.BoolEqual.html#BE">BE</a></span>.<br/>
<br/>
<div class="doc">Applied to a goal of the form <span class="bracket"><span class="id">t</span> -&gt; <span class="id">t</span> -&gt; <span class="id">bool</span></span>, the <span class="bracket"><span class="id">boolean_equality</span></span>
  tactic defines a function with that type, returning <span class="bracket"><span class="id">true</span></span> iff the two
  arguments of type <span class="bracket"><span class="id">t</span></span> are equal.  <span class="bracket"><span class="id">t</span></span> must be an inductive type.
  For any type <span class="bracket"><span class="id">u</span></span> other than <span class="bracket"><span class="id">t</span></span> that appears in arguments of constructors
  of <span class="bracket"><span class="id">t</span></span>, a decidable equality over <span class="bracket"><span class="id">u</span></span> must be provided, as an hypothesis
  of type <span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">u</span>), {<span class="id">x</span>=<span class="id">y</span>}+{<span class="id">x</span>&lt;&gt;<span class="id">y</span>}</span>. </div>
<span class="kwd">Ltac</span> <span class="id">boolean_equality</span> := <span class="id">BE.bool_eq</span>.<br/>
<br/>
<div class="doc">Given a function <span class="bracket"><span class="id">beq</span></span> of type <span class="bracket"><span class="id">t</span> -&gt; <span class="id">t</span> -&gt; <span class="id">bool</span></span> produced by <span class="bracket"><span class="id">boolean_equality</span></span>,
  the <span class="bracket"><span class="id">decidable_equality_from</span> <span class="id">beq</span></span> produces a decidable equality with type
  <span class="bracket"><span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span></span>, {x=y}+{x&lt;&gt;y}. </div>
<br/>
<span class="kwd">Ltac</span> <span class="id">decidable_equality_from</span> <span class="id">beq</span> :=<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id"><a href="compcert.lib.BoolEqual.html#dec_eq_from_bool_eq">BE.dec_eq_from_bool_eq</a></span> <span class="id">_</span> <span class="id">beq</span>); [<span class="id">abstract</span> <span class="id">BE.bool_eq_refl</span>|<span class="id">abstract</span> <span class="id">BE.bool_eq_sound</span>].<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
