
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Interpreter_complete</title>
<meta name="description" content="Documentation of Coq module Interpreter_complete" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Interpreter_complete</h1>
<div class="coq">
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Streams</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ProofIrrelevance</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Equality</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="kwd">Syntax</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Alphabet</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Arith</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Grammar</span>.<br/>
<span class="kwd">Require</span> <span class="id">Automaton</span>.<br/>
<span class="kwd">Require</span> <span class="id">Interpreter</span>.<br/>
<span class="kwd">Require</span> <span class="id">Validator_complete</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">Make</span>(<span class="kwd">Import</span> <span class="id">A</span>:<span class="id">Automaton.T</span>) (<span class="kwd">Import</span> <span class="id">Inter</span>:<span class="id">Interpreter.T</span> <span class="id">A</span>).<br/>
<span class="kwd">Module</span> <span class="kwd">Import</span> <span class="id">Valid</span> := <span class="id">Validator_complete.Make</span> <span class="id">A</span>.<br/>
<br/>
<h1> Completeness Proof *</h1>
<br/>
<span class="kwd">Section</span> <span class="id">Completeness_Proof</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">complete</span>: <span class="id">complete</span>.<br/>
<br/>
<span class="id">Proposition</span> <span class="id">nullable_stable</span>: <span class="id">nullable_stable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5953')">Proof.</div>
<div class="proofscript" id="proof5953">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">first_stable</span>: <span class="id">first_stable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5954')">Proof.</div>
<div class="proofscript" id="proof5954">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">start_future</span>: <span class="id">start_future</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5955')">Proof.</div>
<div class="proofscript" id="proof5955">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">terminal_shift</span>: <span class="id">terminal_shift</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5956')">Proof.</div>
<div class="proofscript" id="proof5956">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">end_reduce</span>: <span class="id">end_reduce</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5957')">Proof.</div>
<div class="proofscript" id="proof5957">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">start_goto</span>: <span class="id">start_goto</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5958')">Proof.</div>
<div class="proofscript" id="proof5958">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">non_terminal_goto</span>: <span class="id">non_terminal_goto</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5959')">Proof.</div>
<div class="proofscript" id="proof5959">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<span class="id">Proposition</span> <span class="id">non_terminal_closed</span>: <span class="id">non_terminal_closed</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5960')">Proof.</div>
<div class="proofscript" id="proof5960">
 <span class="id">pose</span> <span class="id">proof</span> <span class="id">complete</span>; <span class="tactic">unfold</span> <span class="id">Valid.complete</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">intuition</span>. Qed.</div>
<br/>
<div class="doc">If the nullable predicate has been validated, then it is correct. *</div>
<span class="kwd">Lemma</span> <span class="id">nullable_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">head</span> <span class="id">sem</span> <span class="id">word</span>, <span class="id">word</span> = [] -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree</span> <span class="id">head</span> <span class="id">word</span> <span class="id">sem</span> -&gt; <span class="id">nullable_symb</span> <span class="id">head</span> = <span class="id">true</span><br/>
<span class="kwd">with</span> <span class="id">nullable_correct_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">heads</span> <span class="id">sems</span> <span class="id">word</span>, <span class="id">word</span> = [] -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree_list</span> <span class="id">heads</span> <span class="id">word</span> <span class="id">sems</span> -&gt; <span class="id">nullable_word</span> <span class="id">heads</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5961')">Proof with</div>
<div class="proofscript" id="proof5961">
 <span class="tactic">eauto</span>.<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">destruct</span> <span class="id">X</span>.<br/>
<span class="tactic">congruence</span>.<br/>
<span class="tactic">apply</span> <span class="id">nullable_stable</span>...<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">destruct</span> <span class="id">X</span>; <span class="tactic">simpl</span>...<br/>
<span class="tactic">apply</span> <span class="id">andb_true_intro</span>.<br/>
<span class="tactic">apply</span> <span class="id">app_eq_nil</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">split</span>...<br/>
Qed.</div>
<br/>
<div class="doc">If the first predicate has been validated, then it is correct. *</div>
<span class="kwd">Lemma</span> <span class="id">first_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">head</span> <span class="id">sem</span> <span class="id">word</span> <span class="id">t</span> <span class="id">q</span>, <span class="id">word</span> = <span class="id">t</span>::<span class="id">q</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">parse_tree</span> <span class="id">head</span> <span class="id">word</span> <span class="id">sem</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">TerminalSet.In</span> (<span class="id">projT1</span> <span class="id">t</span>) (<span class="id">first_symb_set</span> <span class="id">head</span>)<br/>
<span class="kwd">with</span> <span class="id">first_correct_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">heads</span> <span class="id">sems</span> <span class="id">word</span> <span class="id">t</span> <span class="id">q</span>, <span class="id">word</span> = <span class="id">t</span>::<span class="id">q</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">parse_tree_list</span> <span class="id">heads</span> <span class="id">word</span> <span class="id">sems</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">TerminalSet.In</span> (<span class="id">projT1</span> <span class="id">t</span>) (<span class="id">first_word_set</span> <span class="id">heads</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5962')">Proof with</div>
<div class="proofscript" id="proof5962">
 <span class="tactic">eauto</span>.<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">destruct</span> <span class="id">X</span>.<br/>
<span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>.<br/>
<span class="tactic">apply</span> <span class="id">TerminalSet.singleton_2</span>, <span class="id">compare_refl</span>...<br/>
<span class="tactic">apply</span> <span class="id">first_stable</span>...<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">destruct</span> <span class="id">X</span>.<br/>
<span class="tactic">congruence</span>.<br/>
<span class="tactic">simpl</span>.<br/>
<span class="id">case_eq</span> <span class="id">wordt</span>; <span class="tactic">intros</span>.<br/>
<span class="id">erewrite</span> <span class="id">nullable_correct</span>...<br/>
<span class="tactic">apply</span> <span class="id">TerminalSet.union_3</span>.<br/>
<span class="tactic">subst</span>...<br/>
<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> *; <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">nullable_symb</span> <span class="id">head_symbolt</span>)...<br/>
<span class="tactic">apply</span> <span class="id">TerminalSet.union_2</span>...<br/>
Qed.</div>
<br/>
<span class="kwd">Variable</span> <span class="id">init</span>: <span class="id">initstate</span>.<br/>
<span class="kwd">Variable</span> <span class="id">full_word</span>: <span class="id">list</span> <span class="id">token</span>.<br/>
<span class="kwd">Variable</span> <span class="id">buffer_end</span>: <span class="id">Stream</span> <span class="id">token</span>.<br/>
<span class="kwd">Variable</span> <span class="id">full_sem</span>: <span class="id">symbol_semantic_type</span> (<span class="id">NT</span> (<span class="id">start_nt</span> <span class="id">init</span>)).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">pt_zipper</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">hole_symb</span>:<span class="id">symbol</span>) (<span class="id">hole_word</span>:<span class="id">list</span> <span class="id">token</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">hole_sem</span>:<span class="id">symbol_semantic_type</span> <span class="id">hole_symb</span>), <span class="kwd">Type</span> :=<br/>
| <span class="id">Top_ptz</span>:<br/>
&nbsp;&nbsp;<span class="id">pt_zipper</span> (<span class="id">NT</span> (<span class="id">start_nt</span> <span class="id">init</span>)) (<span class="id">full_word</span>) (<span class="id">full_sem</span>)<br/>
| <span class="id">Cons_ptl_ptz</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">head_symbolt</span>:<span class="id">symbol</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">wordt</span>:<span class="id">list</span> <span class="id">token</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">semantic_valuet</span>:<span class="id">symbol_semantic_type</span> <span class="id">head_symbolt</span>},<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">head_symbolsq</span>:<span class="id">list</span> <span class="id">symbol</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">wordq</span>:<span class="id">list</span> <span class="id">token</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">semantic_valuesq</span>:<span class="id">tuple</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">head_symbolsq</span>)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree_list</span> <span class="id">head_symbolsq</span> <span class="id">wordq</span> <span class="id">semantic_valuesq</span> -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptl_zipper</span> (<span class="id">head_symbolt</span>::<span class="id">head_symbolsq</span>) (<span class="id">wordt</span>++<span class="id">wordq</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">semantic_valuet</span>,<span class="id">semantic_valuesq</span>) -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pt_zipper</span> <span class="id">head_symbolt</span> <span class="id">wordt</span> <span class="id">semantic_valuet</span><br/>
<span class="kwd">with</span> <span class="id">ptl_zipper</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">hole_symbs</span>:<span class="id">list</span> <span class="id">symbol</span>) (<span class="id">hole_word</span>:<span class="id">list</span> <span class="id">token</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">hole_sems</span>:<span class="id">tuple</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">hole_symbs</span>)), <span class="kwd">Type</span> :=<br/>
| <span class="id">Non_terminal_pt_ptlz</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">p</span>:<span class="id">production</span>} {<span class="id">word</span>:<span class="id">list</span> <span class="id">token</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">semantic_values</span>:<span class="id">tuple</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> (<span class="id">rev</span> (<span class="id">prod_rhs_rev</span> <span class="id">p</span>)))},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pt_zipper</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> <span class="id">p</span>)) <span class="id">word</span> (<span class="id">uncurry</span> (<span class="id">prod_action</span> <span class="id">p</span>) <span class="id">semantic_values</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptl_zipper</span> (<span class="id">rev</span> (<span class="id">prod_rhs_rev</span> <span class="id">p</span>)) <span class="id">word</span> <span class="id">semantic_values</span><br/>
<br/>
| <span class="id">Cons_ptl_ptlz</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">head_symbolt</span>:<span class="id">symbol</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">wordt</span>:<span class="id">list</span> <span class="id">token</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">semantic_valuet</span>:<span class="id">symbol_semantic_type</span> <span class="id">head_symbolt</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree</span> <span class="id">head_symbolt</span> <span class="id">wordt</span> <span class="id">semantic_valuet</span> -&gt;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> {<span class="id">head_symbolsq</span>:<span class="id">list</span> <span class="id">symbol</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">wordq</span>:<span class="id">list</span> <span class="id">token</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">semantic_valuesq</span>:<span class="id">tuple</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">head_symbolsq</span>)},<br/>
<br/>
&nbsp;&nbsp;<span class="id">ptl_zipper</span> (<span class="id">head_symbolt</span>::<span class="id">head_symbolsq</span>) (<span class="id">wordt</span>++<span class="id">wordq</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">semantic_valuet</span>,<span class="id">semantic_valuesq</span>) -&gt;<br/>
<br/>
&nbsp;&nbsp;<span class="id">ptl_zipper</span> <span class="id">head_symbolsq</span> <span class="id">wordq</span> <span class="id">semantic_valuesq</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ptlz_cost</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt_ptlz</span> <span class="id">ptz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptz_cost</span> <span class="id">ptz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptlz</span> <span class="id">pt</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_cost</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<span class="kwd">with</span> <span class="id">ptz_cost</span> {<span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptz</span>:<span class="id">pt_zipper</span> <span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Top_ptz</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptz</span> <span class="id">ptl</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 + <span class="id">ptl_size</span> <span class="id">ptl</span> + <span class="id">ptlz_cost</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">pt_dot</span>: <span class="kwd">Type</span> :=<br/>
| <span class="id">Reduce_ptd</span>: <span class="id">ptl_zipper</span> [] [] () -&gt; <span class="id">pt_dot</span><br/>
| <span class="id">Shift_ptd</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">term</span>:<span class="id">terminal</span>) (<span class="id">sem</span>: <span class="id">symbol_semantic_type</span> (<span class="id">T</span> <span class="id">term</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id">symbolsq</span> <span class="id">wordq</span> <span class="id">semsq</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree_list</span> <span class="id">symbolsq</span> <span class="id">wordq</span> <span class="id">semsq</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptl_zipper</span> (<span class="id">T</span> <span class="id">term</span>::<span class="id">symbolsq</span>) (<span class="id">existT</span> (<span class="kwd">fun</span> <span class="id">t</span> =&gt; <span class="id">symbol_semantic_type</span> (<span class="id">T</span> <span class="id">t</span>)) <span class="id">term</span> <span class="id">sem</span>::<span class="id">wordq</span>) (<span class="id">sem</span>, <span class="id">semsq</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pt_dot</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ptd_cost</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Reduce_ptd</span> <span class="id">ptlz</span> =&gt; <span class="id">ptlz_cost</span> <span class="id">ptlz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Shift_ptd</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptl</span> <span class="id">ptlz</span> =&gt; 1 + <span class="id">ptl_size</span> <span class="id">ptl</span> + <span class="id">ptlz_cost</span> <span class="id">ptlz</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ptlz_buffer</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>): <span class="id">Stream</span> <span class="id">token</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt_ptlz</span> <span class="id">ptz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptz_buffer</span> <span class="id">ptz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptlz</span> <span class="id">_</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_buffer</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<span class="kwd">with</span> <span class="id">ptz_buffer</span> {<span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptz</span>:<span class="id">pt_zipper</span> <span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>): <span class="id">Stream</span> <span class="id">token</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Top_ptz</span> =&gt; <span class="id">buffer_end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Cons_ptl_ptz</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">wordq</span> <span class="id">_</span> <span class="id">ptl</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wordq</span>++<span class="id">ptlz_buffer</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ptd_buffer</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Reduce_ptd</span> <span class="id">ptlz</span> =&gt; <span class="id">ptlz_buffer</span> <span class="id">ptlz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Shift_ptd</span> <span class="id">term</span> <span class="id">sem</span> <span class="id">_</span> <span class="id">wordq</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Cons</span> (<span class="id">existT</span> (<span class="kwd">fun</span> <span class="id">t</span> =&gt; <span class="id">symbol_semantic_type</span> (<span class="id">T</span> <span class="id">t</span>)) <span class="id">term</span> <span class="id">sem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">wordq</span> ++ <span class="id">ptlz_buffer</span> <span class="id">ptlz</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ptlz_prod</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>): <span class="id">production</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Non_terminal_pt_ptlz</span> <span class="id">prod</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">prod</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptlz</span> <span class="id">_</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_prod</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ptlz_past</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>): <span class="id">list</span> <span class="id">symbol</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt_ptlz</span> <span class="id">_</span> =&gt; []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Cons_ptl_ptlz</span> <span class="id">s</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span>' =&gt; <span class="id">s</span>::<span class="id">ptlz_past</span> <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ptlz_past_ptlz_prod</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;<span class="id">rev_append</span> <span class="id">hole_symbs</span> (<span class="id">ptlz_past</span> <span class="id">ptlz</span>) = <span class="id">prod_rhs_rev</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5963')">Proof.</div>
<div class="proofscript" id="proof5963">
<span class="id">fix</span> <span class="id">ptlz_past_ptlz_prod</span> 4.<br/>
<span class="tactic">destruct</span> <span class="id">ptlz</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">rewrite</span> &lt;- <span class="id">rev_alt</span>, <span class="id">rev_involutive</span>; <span class="tactic">reflexivity</span>.<br/>
<span class="tactic">apply</span> (<span class="id">ptlz_past_ptlz_prod</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">ptlz_state_compat</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;(<span class="id">state</span>:<span class="id">state</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">state_has_future</span> <span class="id">state</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>) <span class="id">hole_symbs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">projT1</span> (<span class="id">Streams.hd</span> (<span class="id">ptlz_buffer</span> <span class="id">ptlz</span>))).<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ptlz_stack_compat</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;(<span class="id">stack</span>:<span class="id">stack</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">ptlz_state_compat</span> <span class="id">ptlz</span> (<span class="id">state_of_stack</span> <span class="id">init</span> <span class="id">stack</span>) /\<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt_ptlz</span> <span class="id">ptz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptz_stack_compat</span> <span class="id">ptz</span> <span class="id">stack</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Cons_ptl_ptlz</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sem</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">stack</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> <span class="id">sem</span>'::<span class="id">stackq</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span>' <span class="id">stackq</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem</span> ~= <span class="id">sem</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<span class="kwd">with</span> <span class="id">ptz_stack_compat</span> {<span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptz</span>:<span class="id">pt_zipper</span> <span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span>)<br/>
&nbsp;&nbsp;(<span class="id">stack</span>:<span class="id">stack</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Top_ptz</span> =&gt; <span class="id">stack</span> = []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptz</span> <span class="id">_</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span>' <span class="id">stack</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ptlz_stack_compat_ptlz_state_compat</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack</span>:<span class="id">stack</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span> -&gt; <span class="id">ptlz_state_compat</span> <span class="id">ptlz</span> (<span class="id">state_of_stack</span> <span class="id">init</span> <span class="id">stack</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5964')">Proof.</div>
<div class="proofscript" id="proof5964">
<span class="tactic">destruct</span> <span class="id">ptlz</span>; <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">ptd_stack_compat</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>) (<span class="id">stack</span>:<span class="id">stack</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Reduce_ptd</span> <span class="id">ptlz</span> =&gt; <span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Shift_ptd</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span> =&gt; <span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">build_pt_dot</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:<span class="id">pt_dot</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptl</span> <span class="kwd">in</span> <span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">return</span> <span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span> -&gt; <span class="id">_</span><br/>
&nbsp;&nbsp;<span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Nil_ptl</span> =&gt; <span class="kwd">fun</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Reduce_ptd</span> <span class="id">ptlz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl</span> <span class="id">pt</span> <span class="id">ptl</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">pt</span> <span class="kwd">in</span> <span class="id">parse_tree</span> <span class="id">hole_symb</span> <span class="id">hole_word</span> <span class="id">hole_sem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">return</span> <span class="id">ptl_zipper</span> (<span class="id">hole_symb</span>::<span class="id">_</span>) (<span class="id">hole_word</span>++<span class="id">_</span>) (<span class="id">hole_sem</span>,<span class="id">_</span>) -&gt; <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Terminal_pt</span> <span class="id">term</span> <span class="id">sem</span> =&gt; <span class="kwd">fun</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Shift_ptd</span> <span class="id">term</span> <span class="id">sem</span> <span class="id">ptl</span>' <span class="id">ptlz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt</span> <span class="id">ptl</span>'' =&gt; <span class="kwd">fun</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">build_pt_dot</span> <span class="id">ptl</span>''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Non_terminal_pt_ptlz</span> (<span class="id">Cons_ptl_ptz</span> <span class="id">ptl</span>' <span class="id">ptlz</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span> <span class="id">ptlz</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">build_pt_dot_cost</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_cost</span> (<span class="id">build_pt_dot</span> <span class="id">ptl</span> <span class="id">ptlz</span>) = <span class="id">ptl_size</span> <span class="id">ptl</span> + <span class="id">ptlz_cost</span> <span class="id">ptlz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5965')">Proof.</div>
<div class="proofscript" id="proof5965">
<span class="id">fix</span> <span class="id">build_pt_dot_cost</span> 4.<br/>
<span class="tactic">destruct</span> <span class="id">ptl</span>; <span class="tactic">intros</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">destruct</span> <span class="id">p</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">build_pt_dot_cost</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">plus_n_Sm</span>, <span class="id">Nat.add_assoc</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">build_pt_dot_buffer</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_buffer</span> (<span class="id">build_pt_dot</span> <span class="id">ptl</span> <span class="id">ptlz</span>) = <span class="id">hole_word</span> ++ <span class="id">ptlz_buffer</span> <span class="id">ptlz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5966')">Proof.</div>
<div class="proofscript" id="proof5966">
<span class="id">fix</span> <span class="id">build_pt_dot_buffer</span> 4.<br/>
<span class="tactic">destruct</span> <span class="id">ptl</span>; <span class="tactic">intros</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">destruct</span> <span class="id">p</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">build_pt_dot_buffer</span>.<br/>
<span class="tactic">apply</span> <span class="id">app_str_app_assoc</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">ptd_stack_compat_build_pt_dot</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack</span>:<span class="id">stack</span>),<br/>
&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> (<span class="id">build_pt_dot</span> <span class="id">ptl</span> <span class="id">ptlz</span>) <span class="id">stack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5967')">Proof.</div>
<div class="proofscript" id="proof5967">
<span class="id">fix</span> <span class="id">ptd_stack_compat_build_pt_dot</span> 4.<br/>
<span class="tactic">destruct</span> <span class="id">ptl</span>; <span class="tactic">intros</span>.<br/>
<span class="tactic">eauto</span>.<br/>
<span class="tactic">destruct</span> <span class="id">p</span>.<br/>
<span class="tactic">eauto</span>.<br/>
<span class="tactic">simpl</span>.<br/>
<span class="tactic">apply</span> <span class="id">ptd_stack_compat_build_pt_dot</span>.<br/>
<span class="tactic">split</span>.<br/>
<span class="tactic">apply</span> <span class="id">ptlz_stack_compat_ptlz_state_compat</span>, <span class="id">non_terminal_closed</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">clear</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
<span class="tactic">destruct</span> <span class="id">wordq</span>.<br/>
<span class="id">right</span>; <span class="tactic">split</span>.<br/>
<span class="tactic">eauto</span>.<br/>
<span class="tactic">eapply</span> <span class="id">nullable_correct_list</span>; <span class="tactic">eauto</span>.<br/>
<span class="id">left</span>.<br/>
<span class="tactic">eapply</span> <span class="id">first_correct_list</span>; <span class="tactic">eauto</span>.<br/>
<span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Fixpoint</span> <span class="id">pop_ptlz</span> {<span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>}<br/>
&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">word</span>:<span class="id">_</span> &amp; { <span class="id">sem</span>:<span class="id">_</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pt_zipper</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>))) <span class="id">word</span> <span class="id">sem</span> *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>))) <span class="id">word</span> <span class="id">sem</span>)%<span class="id">type</span> } } :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptlz</span> <span class="kwd">in</span> <span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">return</span> <span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">word</span>:<span class="id">_</span> &amp; { <span class="id">sem</span>:<span class="id">_</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pt_zipper</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>))) <span class="id">word</span> <span class="id">sem</span> *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">parse_tree</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>))) <span class="id">word</span> <span class="id">sem</span>)%<span class="id">type</span> } }<br/>
&nbsp;&nbsp;<span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| @<span class="id">Non_terminal_pt_ptlz</span> <span class="id">prod</span> <span class="id">word</span> <span class="id">sem</span> <span class="id">ptz</span> =&gt; <span class="kwd">fun</span> <span class="id">ptl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">sem</span> := <span class="id">uncurry</span> (<span class="id">prod_action</span> <span class="id">prod</span>) <span class="id">sem</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">existT</span> <span class="id">_</span> <span class="id">word</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">sem</span> (<span class="id">ptz</span>, <span class="id">Non_terminal_pt</span> <span class="id">ptl</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptlz</span> <span class="id">pt</span> <span class="id">ptlz</span>' =&gt; <span class="kwd">fun</span> <span class="id">ptl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pop_ptlz</span> (<span class="id">Cons_ptl</span> <span class="id">pt</span> <span class="id">ptl</span>) <span class="id">ptlz</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span> <span class="id">ptl</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pop_ptlz_cost</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;<span class="kwd">let</span> '<span class="id">existT</span> <span class="id">_</span> <span class="id">word</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">sem</span> (<span class="id">ptz</span>, <span class="id">pt</span>)) := <span class="id">pop_ptlz</span> <span class="id">ptl</span> <span class="id">ptlz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">ptlz_cost</span> <span class="id">ptlz</span> = <span class="id">ptz_cost</span> <span class="id">ptz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5968')">Proof.</div>
<div class="proofscript" id="proof5968">
<span class="id">fix</span> <span class="id">pop_ptlz_cost</span> 5.<br/>
<span class="tactic">destruct</span> <span class="id">ptlz</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">pop_ptlz_cost</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pop_ptlz_buffer</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;<span class="kwd">let</span> '<span class="id">existT</span> <span class="id">_</span> <span class="id">word</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">sem</span> (<span class="id">ptz</span>, <span class="id">pt</span>)) := <span class="id">pop_ptlz</span> <span class="id">ptl</span> <span class="id">ptlz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">ptlz_buffer</span> <span class="id">ptlz</span> = <span class="id">ptz_buffer</span> <span class="id">ptz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5969')">Proof.</div>
<div class="proofscript" id="proof5969">
<span class="id">fix</span> <span class="id">pop_ptlz_buffer</span> 5.<br/>
<span class="tactic">destruct</span> <span class="id">ptlz</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">pop_ptlz_buffer</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pop_ptlz_pop_stack_compat_converter</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">A</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span> (<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>),<br/>
&nbsp;&nbsp;<span class="id">arrows_left</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> (<span class="id">rev</span> (<span class="id">prod_rhs_rev</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>)))) <span class="id">A</span> =<br/>
&nbsp;&nbsp;<span class="id">arrows_left</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> <span class="id">hole_symbs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">arrows_right</span> <span class="id">A</span> (<span class="id">map</span> <span class="id">symbol_semantic_type</span> (<span class="id">ptlz_past</span> <span class="id">ptlz</span>))).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5970')">Proof.</div>
<div class="proofscript" id="proof5970">
<span class="tactic">intros</span>.<br/>
<span class="tactic">rewrite</span> &lt;- <span class="id">ptlz_past_ptlz_prod</span>.<br/>
<span class="tactic">unfold</span> <span class="id">arrows_right</span>, <span class="id">arrows_left</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">rev_append_rev</span>, <span class="id">map_rev</span>, <span class="id">map_app</span>, <span class="id">map_rev</span>, &lt;- <span class="id">fold_left_rev_right</span>, <span class="id">rev_involutive</span>, <span class="id">fold_right_app</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">fold_left_rev_right</span>.<br/>
<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pop_ptlz_pop_stack_compat</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptl</span>:<span class="id">parse_tree_list</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> <span class="id">hole_symbs</span> <span class="id">hole_word</span> <span class="id">hole_sems</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack</span>:<span class="id">stack</span>),<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span> -&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">action</span>' :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eq_rect</span> <span class="id">_</span> (<span class="kwd">fun</span> <span class="id">x</span>=&gt;<span class="id">x</span>) (<span class="id">prod_action</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>)) <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pop_ptlz_pop_stack_compat_converter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '<span class="id">existT</span> <span class="id">_</span> <span class="id">word</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">sem</span> (<span class="id">ptz</span>, <span class="id">pt</span>)) := <span class="id">pop_ptlz</span> <span class="id">ptl</span> <span class="id">ptlz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">pop</span> (<span class="id">ptlz_past</span> <span class="id">ptlz</span>) <span class="id">stack</span> (<span class="id">uncurry</span> <span class="id">action</span>' <span class="id">hole_sems</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">stack</span>', <span class="id">sem</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptz_stack_compat</span> <span class="id">ptz</span> <span class="id">stack</span>' /\ <span class="id">sem</span> = <span class="id">sem</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Err</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5971')">Proof.</div>
<div class="proofscript" id="proof5971">
<span class="id">Opaque</span> <span class="id">AlphabetComparable</span> <span class="id">AlphabetComparableUsualEq</span>.<br/>
<span class="id">fix</span> <span class="id">pop_ptlz_pop_stack_compat</span> 5.<br/>
<span class="tactic">destruct</span> <span class="id">ptlz</span>. <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">split</span>.<br/>
<span class="tactic">apply</span> <span class="id">H</span>.<br/>
<span class="tactic">eapply</span> (<span class="tactic">f_equal</span> (<span class="kwd">fun</span> <span class="id">X</span> =&gt; <span class="id">uncurry</span> <span class="id">X</span> <span class="id">semantic_values</span>)).<br/>
<span class="tactic">apply</span> <span class="id">JMeq_eq</span>, <span class="id">JMeq_sym</span>, <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">x</span>).<br/>
<span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">stack0</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">proj2</span> <span class="id">H</span>).<br/>
<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
<span class="tactic">destruct</span> <span class="id">s</span> <span class="kwd">as</span> (<span class="id">state</span>, <span class="id">sem</span>').<br/>
<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
<span class="id">specialize</span> (<span class="id">pop_ptlz_pop_stack_compat</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">Cons_ptl</span> <span class="id">p</span> <span class="id">ptl</span>) <span class="id">ptlz</span> <span class="id">_</span> <span class="id">H0</span>).<br/>
<span class="tactic">destruct</span> (<span class="id">pop_ptlz</span> (<span class="id">Cons_ptl</span> <span class="id">p</span> <span class="id">ptl</span>) <span class="id">ptlz</span>) <span class="kwd">as</span> [<span class="id">word</span> [<span class="id">sem</span> []]].<br/>
<span class="tactic">destruct</span> (<span class="id">compare_eqdec</span> (<span class="id">last_symb_of_non_init_state</span> <span class="id">state</span>) <span class="id">head_symbolt</span>); <span class="tactic">intuition</span>.<br/>
<span class="tactic">eapply</span> <span class="id">JMeq_sym</span>, <span class="id">JMeq_trans</span>, <span class="id">JMeq_sym</span>, <span class="id">JMeq_eq</span> <span class="kwd">in</span> <span class="id">H1</span>; [|<span class="tactic">apply</span> <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">e</span>:=<span class="id">e</span>)].<br/>
<span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>.<br/>
<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">pop_ptlz_pop_stack_compat</span>.<br/>
<span class="id">erewrite</span> <span class="id">proof_irrelevance</span> <span class="kwd">with</span> (<span class="id">p1</span>:=<span class="id">pop_ptlz_pop_stack_compat_converter</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>).<br/>
<span class="tactic">apply</span> <span class="id">pop_ptlz_pop_stack_compat</span>.<br/>
<span class="id">Transparent</span> <span class="id">AlphabetComparable</span> <span class="id">AlphabetComparableUsualEq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">next_ptd</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>): <span class="id">option</span> <span class="id">pt_dot</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Shift_ptd</span> <span class="id">term</span> <span class="id">sem</span> <span class="id">ptl</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">build_pt_dot</span> <span class="id">ptl</span> (<span class="id">Cons_ptl_ptlz</span> (<span class="id">Terminal_pt</span> <span class="id">term</span> <span class="id">sem</span>) <span class="id">ptlz</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Reduce_ptd</span> <span class="id">ptlz</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">existT</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">ptz</span>, <span class="id">pt</span>)) := <span class="id">pop_ptlz</span> <span class="id">Nil_ptl</span> <span class="id">ptlz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ptz</span> <span class="kwd">in</span> <span class="id">pt_zipper</span> <span class="id">sym</span> <span class="id">_</span> <span class="id">_</span> <span class="kwd">return</span> <span class="id">parse_tree</span> <span class="id">sym</span> <span class="id">_</span> <span class="id">_</span> -&gt; <span class="id">_</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Top_ptz</span> =&gt; <span class="kwd">fun</span> <span class="id">pt</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cons_ptl_ptz</span> <span class="id">ptl</span> <span class="id">ptlz</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">pt</span> =&gt; <span class="id">Some</span> (<span class="id">build_pt_dot</span> <span class="id">ptl</span> (<span class="id">Cons_ptl_ptlz</span> <span class="id">pt</span> <span class="id">ptlz</span>'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> <span class="id">pt</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">next_ptd_cost</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ptd</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">next_ptd</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">ptd_cost</span> <span class="id">ptd</span> = 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">ptd</span>' =&gt; <span class="id">ptd_cost</span> <span class="id">ptd</span> = <span class="id">S</span> (<span class="id">ptd_cost</span> <span class="id">ptd</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5972')">Proof.</div>
<div class="proofscript" id="proof5972">
<span class="tactic">destruct</span> <span class="id">ptd</span>. <span class="tactic">unfold</span> <span class="id">next_ptd</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">pop_ptlz_cost</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Nil_ptl</span> <span class="id">p</span>).<br/>
<span class="tactic">destruct</span> (<span class="id">pop_ptlz</span> <span class="id">Nil_ptl</span> <span class="id">p</span>) <span class="kwd">as</span> [<span class="id">word</span>[<span class="id">sem</span>[[]]]].<br/>
<span class="tactic">assumption</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">build_pt_dot_cost</span>.<br/>
<span class="tactic">assumption</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">build_pt_dot_cost</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">reduce_step_next_ptd</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ptlz</span>:<span class="id">ptl_zipper</span> [] [] ()) (<span class="id">stack</span>:<span class="id">stack</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptlz_stack_compat</span> <span class="id">ptlz</span> <span class="id">stack</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">reduce_step</span> <span class="id">init</span> <span class="id">stack</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>) (<span class="id">ptlz_buffer</span> <span class="id">ptlz</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Fail_sr</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Accept_sr</span> <span class="id">sem</span> <span class="id">buffer</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem</span> = <span class="id">full_sem</span> /\ <span class="id">buffer</span> = <span class="id">buffer_end</span> /\ <span class="id">next_ptd</span> (<span class="id">Reduce_ptd</span> <span class="id">ptlz</span>) = <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Progress_sr</span> <span class="id">stack</span> <span class="id">buffer</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">next_ptd</span> (<span class="id">Reduce_ptd</span> <span class="id">ptlz</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">ptd</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> <span class="id">ptd</span> <span class="id">stack</span> /\ <span class="id">buffer</span> = <span class="id">ptd_buffer</span> <span class="id">ptd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Err</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5973')">Proof.</div>
<div class="proofscript" id="proof5973">
<span class="tactic">intros</span>.<br/>
<span class="tactic">unfold</span> <span class="id">reduce_step</span>, <span class="id">next_ptd</span>.<br/>
<span class="tactic">apply</span> <span class="id">pop_ptlz_pop_stack_compat</span> <span class="kwd">with</span> (<span class="id">ptl</span>:=<span class="id">Nil_ptl</span>) <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">pop_ptlz_buffer</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Nil_ptl</span> <span class="id">ptlz</span>).<br/>
<span class="tactic">destruct</span> (<span class="id">pop_ptlz</span> <span class="id">Nil_ptl</span> <span class="id">ptlz</span>) <span class="kwd">as</span> [<span class="id">word</span> [<span class="id">sem</span> [<span class="id">ptz</span> <span class="id">pt</span>]]].<br/>
<span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
<span class="id">revert</span> <span class="id">H</span>.<br/>
<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;|- <span class="kwd">match</span> ?<span class="id">p1</span> <span class="kwd">with</span> <span class="id">Err</span> =&gt; <span class="id">_</span> | <span class="id">OK</span> <span class="id">_</span> =&gt; <span class="id">_</span> <span class="kwd">end</span> -&gt; <span class="kwd">match</span> <span class="id">bind2</span> ?<span class="id">p2</span> <span class="id">_</span> <span class="kwd">with</span> <span class="id">Err</span> =&gt; <span class="id">_</span> | <span class="id">OK</span> <span class="id">_</span> =&gt; <span class="id">_</span> <span class="kwd">end</span> =&gt;<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">p1</span> <span class="kwd">with</span> <span class="id">p2</span>; [<span class="tactic">destruct</span> <span class="id">p2</span> <span class="kwd">as</span> [|[]];  <span class="tactic">intros</span>|]<br/>
<span class="kwd">end</span>.<br/>
<span class="tactic">assumption</span>.<br/>
<span class="tactic">simpl</span>.<br/>
<span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">subst</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">s0</span>.<br/>
<span class="tactic">generalize</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>)); <span class="tactic">clear</span> <span class="id">ptlz</span> <span class="id">stack0</span>.<br/>
<span class="tactic">dependent</span> <span class="tactic">destruction</span> <span class="id">ptz</span>; <span class="tactic">intros</span>.<br/>
<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">subst</span>; <span class="tactic">simpl</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> <span class="id">start_goto</span>; <span class="tactic">unfold</span> <span class="id">Valid.start_goto</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">compare_eqdec</span> (<span class="id">start_nt</span> <span class="id">init</span>) (<span class="id">start_nt</span> <span class="id">init</span>)); <span class="tactic">intuition</span>.<br/>
<span class="tactic">apply</span> <span class="id">JMeq_eq</span>, <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="kwd">fun</span> <span class="id">nt</span> =&gt; <span class="id">symbol_semantic_type</span> (<span class="id">NT</span> <span class="id">nt</span>)).<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">ptlz_stack_compat_ptlz_state_compat</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
<span class="tactic">apply</span> <span class="id">non_terminal_goto</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">goto_table</span> (<span class="id">state_of_stack</span> <span class="id">init</span> <span class="id">s</span>) <span class="id">n</span>) <span class="kwd">as</span> [[]|]; <span class="tactic">intuition</span>.<br/>
<span class="tactic">apply</span> <span class="id">ptd_stack_compat_build_pt_dot</span>; <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">symbol_semantic_type</span>).<br/>
<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">build_pt_dot_buffer</span>.<br/>
<span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">intuition</span>.<br/>
<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">ptlz_stack_compat_ptlz_state_compat</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">H0</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span> <span class="id">eq_refl</span>).<br/>
<span class="tactic">generalize</span> (<span class="id">pop_ptlz_pop_stack_compat_converter</span> (<span class="id">symbol_semantic_type</span> (<span class="id">NT</span> (<span class="id">prod_lhs</span> (<span class="id">ptlz_prod</span> <span class="id">ptlz</span>)))) <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span>).<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">ptlz_past_ptlz_prod</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ptlz</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">clear</span> <span class="id">H</span>.<br/>
<span class="tactic">intro</span>; <span class="tactic">f_equal</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">apply</span> <span class="id">JMeq_eq</span>.<br/>
<span class="id">etransitivity</span>.<br/>
<span class="tactic">apply</span> <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">x</span>).<br/>
<span class="tactic">symmetry</span>.<br/>
<span class="tactic">apply</span> <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">x</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_next_ptd</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>) (<span class="id">stack</span>:<span class="id">stack</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> <span class="id">ptd</span> <span class="id">stack</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">step</span> <span class="id">init</span> <span class="id">stack</span> (<span class="id">ptd_buffer</span> <span class="id">ptd</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Fail_sr</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Accept_sr</span> <span class="id">sem</span> <span class="id">buffer</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem</span> = <span class="id">full_sem</span> /\ <span class="id">buffer</span> = <span class="id">buffer_end</span> /\ <span class="id">next_ptd</span> <span class="id">ptd</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Progress_sr</span> <span class="id">stack</span> <span class="id">buffer</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">next_ptd</span> <span class="id">ptd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">ptd</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> <span class="id">ptd</span> <span class="id">stack</span> /\ <span class="id">buffer</span> = <span class="id">ptd_buffer</span> <span class="id">ptd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Err</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5974')">Proof.</div>
<div class="proofscript" id="proof5974">
<span class="tactic">intros</span>.<br/>
<span class="tactic">destruct</span> <span class="id">ptd</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">ptlz_stack_compat_ptlz_state_compat</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
<span class="tactic">apply</span> <span class="id">end_reduce</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
<span class="tactic">unfold</span> <span class="id">step</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">action_table</span> (<span class="id">state_of_stack</span> <span class="id">init</span> <span class="id">stack0</span>)).<br/>
<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="tactic">by</span> <span class="tactic">reflexivity</span>.<br/>
<span class="tactic">apply</span> <span class="id">reduce_step_next_ptd</span>; <span class="tactic">assumption</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">destruct</span> (<span class="id">Streams.hd</span> (<span class="id">ptlz_buffer</span> <span class="id">p</span>)); <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">l</span> <span class="id">x</span>); <span class="tactic">intuition</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
<span class="tactic">apply</span> <span class="id">reduce_step_next_ptd</span>; <span class="tactic">assumption</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">ptlz_stack_compat_ptlz_state_compat</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
<span class="tactic">apply</span> <span class="id">terminal_shift</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
<span class="tactic">unfold</span> <span class="id">step</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">action_table</span> (<span class="id">state_of_stack</span> <span class="id">init</span> <span class="id">stack0</span>)); <span class="tactic">intuition</span>.<br/>
<span class="tactic">simpl</span>; <span class="tactic">destruct</span> (<span class="id">Streams.hd</span> (<span class="id">ptlz_buffer</span> <span class="id">p0</span>)) <span class="kwd">as</span> [] <span class="id">eqn</span>:?.<br/>
<span class="tactic">destruct</span> (<span class="id">l</span> <span class="id">term</span>); <span class="tactic">intuition</span>.<br/>
<span class="tactic">apply</span> <span class="id">ptd_stack_compat_build_pt_dot</span>; <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
<span class="tactic">unfold</span> <span class="id">ptlz_state_compat</span>; <span class="tactic">simpl</span>; <span class="tactic">destruct</span> <span class="id">Heqt</span>; <span class="tactic">assumption</span>.<br/>
<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">JMeq_eqrect</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">symbol_semantic_type</span>).<br/>
<span class="tactic">rewrite</span> <span class="id">build_pt_dot_buffer</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parse_fix_complete</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ptd</span>:<span class="id">pt_dot</span>) (<span class="id">stack</span>:<span class="id">stack</span>) (<span class="id">n_steps</span>:<span class="id">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> <span class="id">ptd</span> <span class="id">stack</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">parse_fix</span> <span class="id">init</span> <span class="id">stack</span> (<span class="id">ptd_buffer</span> <span class="id">ptd</span>) <span class="id">n_steps</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Parsed_pr</span> <span class="id">sem_res</span> <span class="id">buffer_end_res</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem_res</span> = <span class="id">full_sem</span> /\ <span class="id">buffer_end_res</span> = <span class="id">buffer_end</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">S</span> (<span class="id">ptd_cost</span> <span class="id">ptd</span>) &lt;= <span class="id">n_steps</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Fail_pr</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Timeout_pr</span> =&gt; <span class="id">n_steps</span> &lt; <span class="id">S</span> (<span class="id">ptd_cost</span> <span class="id">ptd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Err</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5975')">Proof.</div>
<div class="proofscript" id="proof5975">
<span class="id">fix</span> <span class="id">parse_fix_complete</span> 3.<br/>
<span class="tactic">destruct</span> <span class="id">n_steps</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">apply</span> <span class="id">Nat.lt_0_succ</span>.<br/>
<span class="tactic">apply</span> <span class="id">step_next_ptd</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">next_ptd_cost</span> <span class="id">ptd</span>).<br/>
<span class="tactic">destruct</span> (<span class="id">step</span> <span class="id">init</span> <span class="id">stack0</span> (<span class="id">ptd_buffer</span> <span class="id">ptd</span>)) <span class="kwd">as</span> [|[]]; <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">H3</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
<span class="tactic">apply</span> <span class="id">le_n_S</span>, <span class="id">Nat.le_0_l</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">next_ptd</span> <span class="id">ptd</span>); <span class="tactic">intuition</span>; <span class="tactic">subst</span>.<br/>
<span class="tactic">eapply</span> <span class="id">parse_fix_complete</span> <span class="kwd">with</span> (<span class="id">n_steps</span>:=<span class="id">n_steps</span>) <span class="kwd">in</span> <span class="id">H1</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
<span class="tactic">destruct</span> (<span class="id">parse_fix</span> <span class="id">init</span> <span class="id">s</span> (<span class="id">ptd_buffer</span> <span class="id">p</span>) <span class="id">n_steps</span>) <span class="kwd">as</span> [|[]]; <span class="tactic">try</span> <span class="tactic">assumption</span>.<br/>
<span class="tactic">apply</span> <span class="id">lt_n_S</span>; <span class="tactic">assumption</span>.<br/>
<span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">H1</span> []]; <span class="tactic">split</span>; [|<span class="tactic">split</span>]; <span class="tactic">try</span> <span class="tactic">assumption</span>.<br/>
<span class="tactic">apply</span> <span class="id">le_n_S</span>; <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Variable</span> <span class="id">full_pt</span>: <span class="id">parse_tree</span> (<span class="id">NT</span> (<span class="id">start_nt</span> <span class="id">init</span>)) <span class="id">full_word</span> <span class="id">full_sem</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">init_ptd</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">full_pt</span> <span class="kwd">in</span> <span class="id">parse_tree</span> <span class="id">head</span> <span class="id">full_word</span> <span class="id">full_sem</span> <span class="kwd">return</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pt_zipper</span> <span class="id">head</span> <span class="id">full_word</span> <span class="id">full_sem</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">head</span> <span class="kwd">return</span> <span class="kwd">Type</span> <span class="kwd">with</span> | <span class="id">T</span> <span class="id">_</span> =&gt; <span class="id">unit</span> | <span class="id">NT</span> <span class="id">_</span> =&gt; <span class="id">pt_dot</span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Terminal_pt</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="kwd">fun</span> <span class="id">_</span> =&gt; ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Non_terminal_pt</span> <span class="id">ptl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">top</span> =&gt; <span class="id">build_pt_dot</span> <span class="id">ptl</span> (<span class="id">Non_terminal_pt_ptlz</span> <span class="id">top</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span> <span class="id">Top_ptz</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_ptd_compat</span>:<br/>
&nbsp;&nbsp;<span class="id">ptd_stack_compat</span> <span class="id">init_ptd</span> [].<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5976')">Proof.</div>
<div class="proofscript" id="proof5976">
<span class="tactic">unfold</span> <span class="id">init_ptd</span>.<br/>
<span class="tactic">assert</span> (<span class="id">ptz_stack_compat</span> <span class="id">Top_ptz</span> []) <span class="tactic">by</span> <span class="tactic">reflexivity</span>.<br/>
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">start_future</span> <span class="id">init</span>); <span class="id">revert</span> <span class="id">H0</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">Top_ptz</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">full_word</span>.<br/>
<span class="tactic">generalize</span> <span class="id">full_sem</span>.<br/>
<span class="tactic">generalize</span> (<span class="id">start_nt</span> <span class="id">init</span>).<br/>
<span class="tactic">dependent</span> <span class="tactic">destruction</span> <span class="id">full_pt0</span>.<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">apply</span> <span class="id">ptd_stack_compat_build_pt_dot</span>; <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
<span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_ptd_cost</span>:<br/>
&nbsp;&nbsp;<span class="id">S</span> (<span class="id">ptd_cost</span> <span class="id">init_ptd</span>) = <span class="id">pt_size</span> <span class="id">full_pt</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5977')">Proof.</div>
<div class="proofscript" id="proof5977">
<span class="tactic">unfold</span> <span class="id">init_ptd</span>.<br/>
<span class="tactic">assert</span> (<span class="id">ptz_cost</span> <span class="id">Top_ptz</span> = 0) <span class="tactic">by</span> <span class="tactic">reflexivity</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">Top_ptz</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">full_word</span>.<br/>
<span class="tactic">generalize</span> <span class="id">full_sem</span>.<br/>
<span class="tactic">generalize</span> (<span class="id">start_nt</span> <span class="id">init</span>).<br/>
<span class="tactic">dependent</span> <span class="tactic">destruction</span> <span class="id">full_pt0</span>.<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">build_pt_dot_cost</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">H</span>, <span class="id">Nat.add_0_r</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_ptd_buffer</span>:<br/>
&nbsp;&nbsp;<span class="id">ptd_buffer</span> <span class="id">init_ptd</span> = <span class="id">full_word</span> ++ <span class="id">buffer_end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5978')">Proof.</div>
<div class="proofscript" id="proof5978">
<span class="tactic">unfold</span> <span class="id">init_ptd</span>.<br/>
<span class="tactic">assert</span> (<span class="id">ptz_buffer</span> <span class="id">Top_ptz</span> = <span class="id">buffer_end</span>) <span class="tactic">by</span> <span class="tactic">reflexivity</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">Top_ptz</span>.<br/>
<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">full_word</span>.<br/>
<span class="tactic">generalize</span> <span class="id">full_sem</span>.<br/>
<span class="tactic">generalize</span> (<span class="id">start_nt</span> <span class="id">init</span>).<br/>
<span class="tactic">dependent</span> <span class="tactic">destruction</span> <span class="id">full_pt0</span>.<br/>
<span class="tactic">intros</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">build_pt_dot_buffer</span>; <span class="tactic">simpl</span>.<br/>
<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">parse_complete</span> <span class="id">n_steps</span>:<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">parse</span> <span class="id">init</span> (<span class="id">full_word</span> ++ <span class="id">buffer_end</span>) <span class="id">n_steps</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> (<span class="id">Parsed_pr</span> <span class="id">sem_res</span> <span class="id">buffer_end_res</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem_res</span> = <span class="id">full_sem</span> /\ <span class="id">buffer_end_res</span> = <span class="id">buffer_end</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pt_size</span> <span class="id">full_pt</span> &lt;= <span class="id">n_steps</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Fail_pr</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">OK</span> <span class="id">Timeout_pr</span> =&gt; <span class="id">n_steps</span> &lt; <span class="id">pt_size</span> <span class="id">full_pt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Err</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5979')">Proof.</div>
<div class="proofscript" id="proof5979">
<span class="id">pose</span> <span class="id">proof</span> (<span class="id">parse_fix_complete</span> <span class="id">init_ptd</span> [] <span class="id">n_steps</span> <span class="id">init_ptd_compat</span>).<br/>
<span class="tactic">rewrite</span> <span class="id">init_ptd_buffer</span>, <span class="id">init_ptd_cost</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
<span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">Completeness_Proof</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">Make</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
